<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>星图连线</title>
<style>
html,body{height:100%;margin:0;background:#000;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans CJK SC','Microsoft YaHei',sans-serif;color:#fff;overflow:hidden}
#game{position:relative;width:100%;height:100vh;overflow:hidden}
canvas{display:block}

/* GIF背景 */
.gif-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -2;
    background: url('https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExYm0wZTR3czhscWpmeXBzdGluNnkzazN0cW0yZHNyZ240NTYydTlhcCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/U3qYN8S0j3bpK/giphy.gif') center center;
    background-size: cover;
    opacity: 0.8;
}

/* 遮罩层，提高UI可读性 */
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    background: rgba(4, 16, 40, 0.7);
}

.ui{
    position:absolute;
    left:16px;
    top:16px;
    z-index:10;
    backdrop-filter:blur(6px);
    background:rgba(255,255,255,0.15);
    padding:10px 12px;
    border-radius:10px;
    font-size:14px;
    border:1px solid rgba(255,255,255,0.2);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.hint{
    position:absolute;
    right:16px;
    top:16px;
    z-index:10;
    backdrop-filter:blur(6px);
    background:rgba(255,255,255,0.15);
    padding:8px 12px;
    border-radius:10px;
    font-size:14px;
    border:1px solid rgba(255,255,255,0.2);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    max-width: 200px;
}
.msg{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    z-index:20;
    text-align:center;
    font-size:32px;
    font-family:'楷体',KaiTi,serif;
    color:#079df3;
    display:none;
    pointer-events:none;
    text-shadow:0 0 10px rgba(7,157,243,0.8);
    background: rgba(4, 16, 40, 0.7);
    padding: 20px 40px;
    border-radius: 15px;
    backdrop-filter: blur(8px);
    border: 1px solid rgba(7,157,243,0.3);
    box-shadow: 0 0 20px rgba(7,157,243,0.3);
}
.msg.show{display:block;animation:pop 500ms ease}

/* 底部信息栏 */
.info-bar {
    position: absolute;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    backdrop-filter: blur(6px);
    background: rgba(255,255,255,0.15);
    padding: 10px 20px;
    border-radius: 10px;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.2);
    text-align: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

/* 重置按钮 */
.reset-btn {
    position: absolute;
    bottom: 16px;
    right: 16px;
    z-index: 10;
    backdrop-filter: blur(6px);
    background: rgba(255,255,255,0.15);
    padding: 8px 16px;
    border-radius: 10px;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.2);
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.reset-btn:hover {
    background: rgba(255,255,255,0.25);
    transform: scale(1.05);
}

@keyframes pop{from{transform:translate(-50%,-50%) scale(0.8);opacity:0}to{transform:translate(-50%,-50%) scale(1);opacity:1}}
</style>
</head>
<body>
<!-- 动态GIF背景 -->
<div class="gif-background"></div>
<div class="overlay"></div>

<div id="game">
  <canvas id="c"></canvas>
  <div class="ui"><strong>点击或拖动连接星星</strong></div>
  <div class="hint">提示：我们的使命是...</div>
  <div class="info-bar">目标：连接所有星点形成对应星象</div>
  <button class="reset-btn" id="resetBtn">重置</button>
  <div id="msg" class="msg"><div id="msgText"></div></div>
</div>

<script>
(function(){
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const msg=document.getElementById('msg');
const msgText=document.getElementById('msgText');
const resetBtn=document.getElementById('resetBtn');

let xScale=0.6; // 水平压缩比例
let xOffset=0;

function resize(){
  canvas.width=window.innerWidth;
  canvas.height=window.innerHeight;
  xOffset=canvas.width*(1-xScale)/2;
  genBackgroundStars();
  reset();
}
window.addEventListener('resize',resize);

// 背景星
const backgroundStars=[];
function genBackgroundStars(){
  backgroundStars.length=0;
  const n=Math.max(120,Math.floor((canvas.width*canvas.height)/6000));
  for(let i=0;i<n;i++){
    backgroundStars.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,r:Math.random()*1.4+0.2,alpha:Math.random()*0.7+0.25});
  }
}

// 星点
const libraNormalized=[
  {x:0.6,y:0.16},{x:0.3,y:0.28},{x:0.71,y:0.43},{x:0.32,y:0.46},
  {x:0.7,y:0.81},{x:0.32,y:0.53},{x:0.67,y:0.73},{x:0.3,y:0.64}
];

function makeLibraPoints(){
  return libraNormalized.map(p=>({
    x:p.x*canvas.width*xScale+xOffset,
    y:p.y*canvas.height,
    r:7,
    connected:false
  }));
}

let libraPoints=[],drawnEdgesSet=new Set(),hoverIdx=-1,startIdx=-1;

function reset(){
  libraPoints=makeLibraPoints();
  drawnEdgesSet.clear();
  hoverIdx=-1;
  startIdx=-1;
  msg.classList.remove('show');
  draw();
}

function findNearestStar(x,y,threshold=32){
  let best=-1,bestd=threshold*threshold;
  for(let i=0;i<libraPoints.length;i++){
    const p=libraPoints[i];
    const dx=p.x-x,dy=p.y-y;
    const d2=dx*dx+dy*dy;
    if(d2<bestd){bestd=d2;best=i;}
  }
  return best;
}

function edgeKey(a,b){ const A=Math.min(a,b),B=Math.max(a,b); return `${A}-${B}`; }

function checkWin(){
  const chains=[[0,1,2],[0,1,3,5,7],[0,2,4,6]];
  const adj={}; for(let i=0;i<libraPoints.length;i++) adj[i]=[];
  drawnEdgesSet.forEach(k=>{const [a,b]=k.split('-').map(Number);adj[a].push(b);adj[b].push(a);});
  function dfs(from,to,visited){
    if(from===to) return true;
    visited.add(from);
    for(let nxt of adj[from]){
      if(!visited.has(nxt)) if(dfs(nxt,to,visited)) return true;
    }
    return false;
  }
  function isChainConnected(chain){
    for(let i=0;i<chain.length-1;i++) if(!dfs(chain[i],chain[i+1],new Set())) return false;
    return true;
  }
  for(let chain of chains) if(!isChainConnected(chain)) return false;
  return true;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  // 绘制半透明背景，提高可读性
  ctx.fillStyle = 'rgba(4, 16, 40, 0.4)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 绘制星云效果
  ctx.save(); ctx.globalAlpha=0.08; ctx.fillStyle='#7db3ff';
  ctx.beginPath();
  ctx.ellipse(canvas.width*0.55, canvas.height*0.28, canvas.width*0.4, canvas.height*0.18,0,0,Math.PI*2);
  ctx.fill(); ctx.restore();

  // 绘制背景星
  for(const s of backgroundStars){ctx.beginPath();ctx.globalAlpha=s.alpha;ctx.fillStyle='#fff';ctx.arc(s.x,s.y,s.r,0,Math.PI*2);ctx.fill();}
  ctx.globalAlpha=1;

  // 绘制连线
  ctx.lineWidth=3; ctx.lineJoin='round'; ctx.lineCap='round';
  for(const key of drawnEdgesSet){
    const [a,b]=key.split('-').map(Number);
    const A=libraPoints[a],B=libraPoints[b];
    ctx.strokeStyle='rgba(200,230,255,0.95)';
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    ctx.save(); ctx.globalCompositeOperation='lighter';
    const mx=(A.x+B.x)/2,my=(A.y+B.y)/2;
    const rad=ctx.createRadialGradient(mx,my,0,mx,my,28);
    rad.addColorStop(0,'rgba(200,230,255,0.18)');rad.addColorStop(1,'rgba(200,230,255,0)');
    ctx.fillStyle=rad; ctx.beginPath(); ctx.arc(mx,my,28,0,Math.PI*2); ctx.fill(); ctx.restore();
  }

  // 绘制当前正在拖动的连线
  if(startIdx!==-1 && lastPointerPos){
    const A=libraPoints[startIdx];
    ctx.strokeStyle='rgba(200,230,255,0.6)'; ctx.lineWidth=2; ctx.setLineDash([6,8]);
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(lastPointerPos.x,lastPointerPos.y); ctx.stroke();
    ctx.setLineDash([]);
  }

  // 绘制星点
  for(let i=0;i<libraPoints.length;i++){
    const p=libraPoints[i]; const isHover=(i===hoverIdx);
    ctx.beginPath();
    const glow=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,24);
    glow.addColorStop(0,isHover?'rgba(255,255,220,0.95)':'rgba(255,255,255,0.85)');
    glow.addColorStop(0.25,'rgba(220,230,255,0.28)');glow.addColorStop(1,'rgba(220,230,255,0)');
    ctx.fillStyle=glow;ctx.arc(p.x,p.y,24,0,Math.PI*2);ctx.fill();
    ctx.beginPath(); ctx.fillStyle='#fff';ctx.arc(p.x,p.y,p.r,0,Math.PI*2);ctx.fill();
  }
}

let isPointerDown=false,lastPointerPos=null;

function pointerPos(e){const rect=canvas.getBoundingClientRect();const x=(e.touches?e.touches[0].clientX:e.clientX)-rect.left;const y=(e.touches?e.touches[0].clientY:e.clientY)-rect.top;return {x,y};}

canvas.addEventListener('mousemove',e=>{lastPointerPos=pointerPos(e);hoverIdx=findNearestStar(lastPointerPos.x,lastPointerPos.y,30);draw();});
canvas.addEventListener('touchmove',e=>{lastPointerPos=pointerPos(e);hoverIdx=findNearestStar(lastPointerPos.x,lastPointerPos.y,30);draw();},{passive:false});

canvas.addEventListener('mousedown',e=>{isPointerDown=true;const pos=pointerPos(e);const idx=findNearestStar(pos.x,pos.y,32);if(idx>=0){if(startIdx!==-1&&startIdx!==idx){connectTwo(startIdx,idx);startIdx=-1;}else startIdx=idx;}else startIdx=-1;draw();});
canvas.addEventListener('touchstart',e=>{e.preventDefault();isPointerDown=true;const pos=pointerPos(e);const idx=findNearestStar(pos.x,pos.y,32);if(idx>=0){if(startIdx!==-1&&startIdx!==idx){connectTwo(startIdx,idx);startIdx=-1;}else startIdx=idx;}else startIdx=-1;draw();},{passive:false});

function onPointerUp(e){isPointerDown=false;const pos=pointerPos(e);const idx=findNearestStar(pos.x,pos.y,32);if(startIdx!==-1 && idx>=0 && idx!==startIdx) connectTwo(startIdx,idx);startIdx=-1;draw();}
canvas.addEventListener('mouseup',onPointerUp);
canvas.addEventListener('touchend',e=>{e.preventDefault();if(startIdx!==-1 && lastPointerPos){const idx=findNearestStar(lastPointerPos.x,lastPointerPos.y,32);if(idx>=0&&idx!==startIdx) connectTwo(startIdx,idx);}startIdx=-1;isPointerDown=false;draw();},{passive:false});

function connectTwo(a,b){if(a===b) return;const key=edgeKey(a,b);if(!drawnEdgesSet.has(key)) drawnEdgesSet.add(key);if(checkWin()) showMessage('5pyI5rSb5q6L5Y23');}
function showMessage(text){msgText.innerText=text;msg.classList.add('show');}

// 重置按钮事件
resetBtn.addEventListener('click', reset);

// 初始化
resize();
canvas.style.cursor='crosshair';
})();
</script>
</body>
</html>